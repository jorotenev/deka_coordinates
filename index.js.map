{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/map.ts","webpack:///./src/geo_utils.ts","webpack:///./src/core.ts","webpack:///./src/app.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","map","layerForUserRectangles","L","setView","tileLayer","attribution","maxZoom","id","accessToken","addTo","control","sidebar","FeatureGroup","addLayer","drawControl","Control","Draw","edit","featureGroup","draw","circle","circlemarker","marker","polygon","polyline","addControl","canvas","padding","drawCircles","coords","layer","circleRadius","circleOptions","__assign","color","forEach","coord","radius","EARTH_RADIUS","calculateNextPoint","coordinate","distance","bearing","delta","Number","theta","toRadians","phi1","lat","lambda1","lng","sinphi1","Math","sin","cosphi1","cos","sindelta","cosdelta","sintheta","sinphi2","phi2","asin","y","x","lambda2","atan2","point","latLng","toDegrees","isWithinBounds","bounds","num","minLat","min","apply","maxLat","max","PI","Bearing","RectangleSide","callbackOnRectDrawn","callbackOnDelete","circlesLayer","circleCoordsOfRow","initialCoord","eastBound","getEast","result","currentPosition","push","east","moveToSouthEast","currentRowInitial","dist","south","$","attr","drawnRectangle","clearLayers","redrawBtn","document","getElementById","onclick","boundingRectangle","circle_radius","val","console","log","options","fillers","rectBounds","getBounds","initialPoint","freeze","getNorthWest","currentCoord","row","currentRowCirclesCoords","fillerFirstCoord","getNorth","getSouth","helperRowCoords","pop","main","combined","concat","createCoordinates","downloadBtn","length","toSave","coordinates","area_name","prompt","data","filename","contentType","blob","Blob","type","window","navigator","msSaveOrOpenBlob","msSaveBlob","elem","createElement","href","URL","createObjectURL","download","body","appendChild","click","removeChild","saveFile","JSON","stringify","bind","on","e","layerType","latlngs","getLatLngs","rectangleBounds","latLngBounds","rectangle"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export let map;\nexport let layerForUserRectangles;\ndeclare let L;\n// add the map to the page\nmap = L.map('map').setView([42.697930, 23.321628], 13);\nL.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {\n    attribution: 'Map data &copy; <createCoordinatesReturn href=\"http://openstreetmap.org\">OpenStreetMap</createCoordinatesReturn> contributors, <createCoordinatesReturn href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</createCoordinatesReturn>, Imagery © <createCoordinatesReturn href=\"http://mapbox.com\">Mapbox</createCoordinatesReturn>',\n    maxZoom: 18,\n    id: 'mapbox.streets-basic',\n    accessToken: 'pk.eyJ1IjoiY2hpcHNhbiIsImEiOiJqa0JwV1pnIn0.mvduWzyRdcHxK_QIOpetFg'\n}).addTo(map);\n\n\n// the collapsible sidebar with redraw/download etc. custom buttons\nlet sidebar = L.control.sidebar('sidebar').addTo(map);\n\n// where we draw rectangles\nlayerForUserRectangles = new L.FeatureGroup();\nmap.addLayer(layerForUserRectangles);\n// enable the plugin for drawing on the map\nlet drawControl = new L.Control.Draw({\n    edit: {\n        featureGroup: layerForUserRectangles\n    },\n    draw: {\n        circle: false,\n        circlemarker: false,\n        marker: false,\n        polygon: false,\n        polyline: false,\n    }\n});\nmap.addControl(drawControl);\n\n/**\n * A function which collects what the user has drawn and pass it to a callback\n * @param {(rectangle: Rectangle) => any} callbackOnRectDrawn\n * @param {() => void} callbackOnDelete\n */\nexport function enableDrawing(callbackOnRectDrawn: (rectangle: L.Rectangle) => any, callbackOnDelete: () => void) {\n    // todo handle \"edited\" too\n    map.on('draw:created', function (e) {\n        let type = e.layerType,\n            layer = e.layer;\n        if (type !== \"rectangle\") {\n            return true\n        }\n        layerForUserRectangles.clearLayers();\n        console.log(type + \" drawn\");\n        let latlngs = layer.getLatLngs()[0];\n        layerForUserRectangles.addLayer(layer);\n\n        console.log(\"Boundaries of the area of interest:\");\n        console.log(JSON.stringify(latlngs));\n\n        // prepare the result to be used for constructing a rectangle\n        const rectangleBounds: L.LatLngBounds = L.latLngBounds(latlngs.map(function (coord): [number, number] {\n            return [coord.lat, coord.lng]\n        }));\n        // make the rectangle, which encompasses the area which we want to fill with circles\n        const boundingRectangle: L.Rectangle = L.rectangle(rectangleBounds);\n\n        // pass the rectangle to the callback\n        callbackOnRectDrawn(boundingRectangle);\n    });\n    map.on(\"draw:deleted\", callbackOnDelete)\n\n}\n\nvar myRenderer = L.canvas({padding: 0.5});\n\n/**\n * Given a layer, coordinates of the center of circles and the radius of the circle,\n * draw the circles on the layer\n * @param {LatLng[]} coords\n * @param {LayerGroup} layer\n * @param {number} circleRadius\n * @param {{}} circleOptions\n */\nexport function drawCircles(coords: L.LatLng[], layer: L.LayerGroup, circleRadius = 300, circleOptions = {}) {\n    let opts = {\n        color: \"red\",\n        ...circleOptions\n    };\n    coords.forEach((coord: L.LatLng) => {\n        L.circle(coord, {radius: circleRadius}, circleOptions).addTo(layer)\n    })\n}\n\n\n\n","/*\n *  Credits: http://www.movable-type.co.uk/scripts/latlong.html\n * -> latlon-spherical.js\n */\ndeclare let L;\nconst EARTH_RADIUS = 6371e3;\n\n/**\n * \"Destination point given distance and bearing from start point\"\n * i.e. given a point (lat,lng), direction and distance, calculate the destination coordinates\n * Credits: http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param coordinate : the start point\n * @param {number} distance, in metres\n * @param {number} bearing - direction, in degrees from north clockwise\n * @return the new point and the new bearing\n * */\nexport function calculateNextPoint(coordinate: L.LatLng, distance = 500, bearing): { point: L.LatLng} {\n\n    let delta = Number(distance) / EARTH_RADIUS; // angular distance in radians\n    let theta = toRadians(Number(bearing));\n\n    let phi1 = toRadians(coordinate.lat);\n    let lambda1 = toRadians(coordinate.lng);\n\n    let sinphi1 = Math.sin(phi1), cosphi1 = Math.cos(phi1);\n    let sindelta = Math.sin(delta), cosdelta = Math.cos(delta);\n    let sintheta = Math.sin(theta), costheta = Math.cos(theta);\n\n    let sinphi2 = sinphi1 * cosdelta + cosphi1 * sindelta * costheta;\n    let phi2 = Math.asin(sinphi2);\n    let y = sintheta * sindelta * cosphi1;\n    let x = cosdelta - sinphi1 * sinphi2;\n    let lambda2 = lambda1 + Math.atan2(y, x);\n\n    const destinationPoint = L.latLng(toDegrees(phi2), (toDegrees(lambda2) + 540) % 360 - 180); // normalise to −180..+180°,\n\n    return {\n        point: destinationPoint\n    }\n}\n\n/**\n * `num` is a latitude/longitude coordinate and `bounds` is a line.\n * This method checks if `num` is within this line.\n * E.g. we have a line that goes from north to south - from [lat:40 lng:30] to [lat:40 lng:20] and we want to check if\n * lng:25 is within the bounds of the line.\n * when using this method the bounds would be [30,20] and num=25.\n *\n * @param {[number , number]} bounds\n * @param {number} num\n * @return {boolean}\n */\nexport function isWithinBounds(bounds: [number, number], num: number) {\n    let minLat = Math.min(...bounds), maxLat = Math.max(...bounds);\n    return (minLat <= num) && (num <= maxLat);\n}\n\nfunction toRadians(num) {\n    return num * Math.PI / 180\n}\n\nfunction toDegrees(num) {\n    return num * 180 / Math.PI\n}\n\n\n\n\n","import {calculateNextPoint, isWithinBounds} from \"./geo_utils\";\n\nexport const DEFAULT_CIRCLE_RADIUS = 150; // meters\ndeclare let L;\n\ntype createCoordinatesOpts = {\n    boundingRectangle: L.Rectangle,\n    distance: number,\n}\ntype createCoordinatesReturn = { main: L.LatLng[], fillers: L.LatLng[], combined: L.LatLng[] };\n\n/**\n * This function is the core of the whole repo.\n *\n * The function receives createCoordinatesReturn rectangle and wants to figure out\n * the coordinates of the centers of circles, such that the circles fill out the whole rectangle.\n * We allow for the circles to overlap.\n *\n * All circles discussed below have the same radius (R = @options.dist/2).\n *\n * The function \"iterates\" the rectangle from west-to-east, north-to-south.\n * A row is createCoordinatesReturn \"line\" from west-to-east.\n *\n * On each row the circles are next to each other, without overlapping (i.e. 0 distance b/w circles on createCoordinatesReturn row)\n * There's no distance between circles on adjacent columns too.\n * This means that these \"main\" circles will not fill up the whole rectangle.\n *\n * Thus, between each two adjacent \"main\" rows (e.g. rows A and B)  we insert createCoordinatesReturn filler row (F).\n * Row F is effectively copy of A but shifted first south and then east by the radius R. The last element of the filler\n * row is removed since it's too far from the east end of the bounding rectangle.\n *\n * @param {createCoordinatesOpts} options. .dist is the distance between the centers of two circles. i.e. it is the radius of createCoordinatesReturn circle\n * @return {createCoordinatesReturn}\n */\nexport function createCoordinates(options: createCoordinatesOpts): createCoordinatesReturn {\n    const result: L.LatLng[] = [], fillers: L.LatLng[] = [];\n\n    const rectBounds = options.boundingRectangle.getBounds();\n    const initialPoint = Object.freeze(rectBounds.getNorthWest());\n\n    let currentCoord: L.LatLng = initialPoint;\n    let currentRowInitial = currentCoord;\n    for (let row = 1; ; row++) {\n\n        let currentRowCirclesCoords = circleCoordsOfRow(rectBounds, currentRowInitial, options.distance);\n        result.push(...currentRowCirclesCoords);\n\n        let fillerFirstCoord = moveToSouthEast(currentRowInitial, options.distance);\n\n        if (!isWithinBounds([rectBounds.getNorth(), rectBounds.getSouth()], currentCoord.lat)) {\n            break;\n        } else {\n            let helperRowCoords: L.LatLng[] = circleCoordsOfRow(rectBounds, fillerFirstCoord, options.distance);\n            helperRowCoords.pop();\n            fillers.push(...helperRowCoords);\n        }\n\n        currentRowInitial = currentCoord = calculateNextPoint(initialPoint, options.distance * row, Bearing.south).point;\n    }\n    return {main: result, fillers: fillers, combined: result.concat(fillers)}\n\n}\n\n/**\n * (generates rows for createCoordinates())\n * Generate the coordinates of circles on createCoordinatesReturn generic row (i.e. used for both \"main\"/\"filler\" rows).\n *\n * The function starts from createCoordinatesReturn given @initialCoord and moves east. On each iteration it checks if the current\n * coordinate is within the longitude bounds of the rect (i.e. at most one circle beyond the east side of the rect).\n * If it's beyond - the function returns the row. Since we add to the result before we make the bound check,\n * we allow for at most one circle beyond the bounds.\n *\n * @param {LatLngBounds} bounds - the bounds of the big rectangle around the city\n * @param {LatLng} initialCoord - where is the centre of the first circle on that row\n * @param distance - the distance between the centers of two adjacent circles on this row\n * @return {LatLng[]} the coordinates of the centers of all circles on this row\n */\nfunction circleCoordsOfRow(bounds: L.LatLngBounds, initialCoord: L.LatLng, distance) {\n    const eastBound = bounds.getEast();\n\n    let result: L.LatLng[] = [];\n    let currentPosition: L.LatLng = initialCoord;\n    for (; ;) {\n        result.push(currentPosition);\n        /*\n        use initialCoord.lng instead of \"westBound\" because of createCoordinatesReturn numerical error propagated up from calculateNextPoint().\n        the error increases the more we go south from the north-west point of @bounds.\n\n        tl;dr it's due to the fact that the earth has an imperfect shape\n        */\n        if (!isWithinBounds([initialCoord.lng, eastBound], currentPosition.lng)) {\n            break\n        }\n        currentPosition = calculateNextPoint(currentPosition, distance, Bearing.east).point;\n    }\n\n    return result;\n}\n\nfunction moveToSouthEast(currentRowInitial, dist) {\n    let shiftSouth = calculateNextPoint(currentRowInitial, dist / 2, Bearing.south).point;\n    return calculateNextPoint(shiftSouth, dist / 2, Bearing.east).point;\n}\n\n// i.e. direction\nenum Bearing {\n    east = 90,\n    west = -90,\n\n    north = 0,\n    south = 180\n}\n\nenum RectangleSide {\n    // todo add others\n    northWest = \"NorthWest\"\n}\n\n\n\n","import {map, drawCircles, enableDrawing} from \"./map\"\nimport {DEFAULT_CIRCLE_RADIUS, createCoordinates} from \"./core\"\n\n// jquery and leaflet are \"imported\" in the html via <script>\ndeclare let $;\ndeclare let L;\n\n\n/**\n * Orchestrate it all\n */\n(function run() {\n    // the leaflet layer on which the circles generated circles will be drawn\n    const circlesLayer = new L.FeatureGroup().addTo(map);\n\n    // set default circle radius\n    $(\"#radius-size\").attr(\"value\", DEFAULT_CIRCLE_RADIUS);\n\n    // attach a callback to the event when a user has drawn a rectangle on the map.\n    // the defining coords of the rectangle are then passed to a callback that we set here\n    enableDrawing(\n        onCityBoundaryReady.bind(null, circlesLayer),\n        () => circlesLayer.clearLayers());\n})();\n\n/**\n * Given a bounding rectangle and a \"canvas\", generated the circles and fill the canvas with them\n *\n * @param {Rectangle} boundingRectangle\n * @param circlesLayer - the \"canvas\"\n */\nfunction regenerate(boundingRectangle: L.Rectangle, circlesLayer) {\n    // wipe out existing circles\n    circlesLayer.clearLayers();\n\n    // the radius of the circles that will fill the rectangle\n    const circle_radius = getUserSelectedCircleRadius(); // metres\n    console.log(`${circle_radius}m circle radius`);\n\n    // generate all the coordinates of the circles within the bounding area\n    // *only* the coordinates of the *center* of the circles is returned\n    const coords = createCoordinates({\n        boundingRectangle: boundingRectangle,\n        distance: circle_radius * 2,\n    });\n    // .main & .fillers is used to debug easily. The union of the two sets of circles\n    // is in .combined\n    drawCircles(coords.main, circlesLayer, circle_radius);\n    drawCircles(coords.fillers, circlesLayer, circle_radius, {color: 'green'});\n\n    let downloadBtn = document.getElementById('download-btn');\n\n    console.log(`Generated ${coords.combined.length} circles `);\n    console.log(boundingRectangle)\n    downloadBtn.onclick = function () {\n        const toSave = {\n            coordinates: coords.combined,\n            circle_radius: circle_radius,\n            area_name: prompt(\"Enter area name\", \"\"),\n\n            // coords_bounding_rectangle: {northwest: {lat: boundingRectangle.getBounds()., lng: 1}, southeast: {lat: 1, lng: 1}}\n        };\n        saveFile(JSON.stringify(toSave), `coords_${toSave.coordinates.length}_r${circle_radius}.json`, 'application/json');\n    };\n}\n\n\n/**\n * Called when the user has drawn a rectangle\n * @param circlesLayer the layer on which we want to draw the generated circles\n * @param {LatLng[]} drawnRectangle\n */\nfunction onCityBoundaryReady(circlesLayer, drawnRectangle: L.Rectangle) {\n    circlesLayer.clearLayers();\n\n    const redrawBtn = document.getElementById('regenerate-btn');\n    redrawBtn.onclick = regenerate.bind(null, drawnRectangle, circlesLayer);\n    redrawBtn.click();\n}\n\nfunction getUserSelectedCircleRadius() {\n    return Number($(\"#radius-size\").val());\n}\n\n\n/**\n * https://stackoverflow.com/a/33542499\n * Save a file to the local filesystem\n * @param data\n * @param filename\n * @param contentType\n */\nfunction saveFile(data, filename, contentType) {\n    let blob = new Blob([data], {type: contentType});\n    if (window.navigator.msSaveOrOpenBlob) {\n        window.navigator.msSaveBlob(blob, filename);\n    }\n    else {\n        let elem = window.document.createElement('a');\n        elem.href = window.URL.createObjectURL(blob);\n        elem.download = filename;\n        document.body.appendChild(elem);\n        elem.click();\n        document.body.removeChild(elem);\n    }\n}\n\n\n"],"sourceRoot":""}