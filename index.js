/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/app.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/app.ts":
/*!********************!*\
  !*** ./src/app.ts ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map */ \"./src/map.ts\");\n/* harmony import */ var _core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core */ \"./src/core.ts\");\n\n\n/**\n * Orchestrate it all\n */\n(function run() {\n    // the leaflet layer on which the circles generated circles will be drawn\n    var circlesLayer = new L.FeatureGroup().addTo(_map__WEBPACK_IMPORTED_MODULE_0__[\"map\"]);\n    // set default circle radius\n    $(\"#radius-size\").attr(\"value\", _core__WEBPACK_IMPORTED_MODULE_1__[\"DEFAULT_CIRCLE_RADIUS\"]);\n    // attach a callback to the event when a user has drawn a rectangle on the map.\n    // the defining coords of the rectangle are then passed to a callback that we set here\n    Object(_map__WEBPACK_IMPORTED_MODULE_0__[\"enableDrawing\"])(onCityBoundaryReady.bind(null, circlesLayer), function () { return circlesLayer.clearLayers(); });\n})();\n/**\n * Given a bounding rectangle and a \"canvas\", generated the circles and fill the canvas with them\n *\n * @param {Rectangle} boundingRectangle\n * @param circlesLayer - the \"canvas\"\n */\nfunction regenerate(boundingRectangle, circlesLayer) {\n    // wipe out existing circles\n    circlesLayer.clearLayers();\n    // the radius of the circles that will fill the rectangle\n    var circle_radius = getUserSelectedCircleRadius(); // metres\n    console.log(circle_radius + \"m circle radius\");\n    // generate all the coordinates of the circles within the bounding area\n    // *only* the coordinates of the *center* of the circles is returned\n    var coords = Object(_core__WEBPACK_IMPORTED_MODULE_1__[\"createCoordinates\"])({\n        boundingRectangle: boundingRectangle,\n        distance: circle_radius * 2,\n    });\n    // .main & .fillers is used to debug easily. The union of the two sets of circles\n    // is in .combined\n    Object(_map__WEBPACK_IMPORTED_MODULE_0__[\"drawCircles\"])(coords.main, circlesLayer, circle_radius);\n    Object(_map__WEBPACK_IMPORTED_MODULE_0__[\"drawCircles\"])(coords.fillers, circlesLayer, circle_radius, { color: 'green' });\n    var downloadBtn = document.getElementById('download-btn');\n    console.log(\"Generated \" + coords.combined.length + \" circles \");\n    downloadBtn.onclick = function () {\n        var nw = boundingRectangle.getBounds().getNorthWest();\n        var se = boundingRectangle.getBounds().getSouthEast();\n        var area_name = prompt(\"Enter area name\", \"\");\n        var toSave = {\n            area_name: area_name,\n            circle_radius: circle_radius,\n            bounding_rectangle: {\n                northwest: { lat: nw.lat, lng: nw.lng },\n                southeast: { lat: se.lat, lng: se.lng },\n            },\n            coordinates: coords.combined,\n        };\n        saveFile(JSON.stringify(toSave), area_name + \"_coords_\" + toSave.coordinates.length + \"_r\" + circle_radius + \".json\", 'application/json');\n    };\n}\n/**\n * Called when the user has drawn a rectangle\n * @param circlesLayer the layer on which we want to draw the generated circles\n * @param {LatLng[]} drawnRectangle\n */\nfunction onCityBoundaryReady(circlesLayer, drawnRectangle) {\n    circlesLayer.clearLayers();\n    var redrawBtn = document.getElementById('regenerate-btn');\n    redrawBtn.onclick = regenerate.bind(null, drawnRectangle, circlesLayer);\n    redrawBtn.click();\n}\nfunction getUserSelectedCircleRadius() {\n    return Number($(\"#radius-size\").val());\n}\n/**\n * https://stackoverflow.com/a/33542499\n * Save a file to the local filesystem\n * @param data\n * @param filename\n * @param contentType\n */\nfunction saveFile(data, filename, contentType) {\n    var blob = new Blob([data], { type: contentType });\n    if (window.navigator.msSaveOrOpenBlob) {\n        window.navigator.msSaveBlob(blob, filename);\n    }\n    else {\n        var elem = window.document.createElement('a');\n        elem.href = window.URL.createObjectURL(blob);\n        elem.download = filename;\n        document.body.appendChild(elem);\n        elem.click();\n        document.body.removeChild(elem);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvYXBwLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC50cz8wNjZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7bWFwLCBkcmF3Q2lyY2xlcywgZW5hYmxlRHJhd2luZ30gZnJvbSBcIi4vbWFwXCJcbmltcG9ydCB7REVGQVVMVF9DSVJDTEVfUkFESVVTLCBjcmVhdGVDb29yZGluYXRlc30gZnJvbSBcIi4vY29yZVwiXG5cbi8vIGpxdWVyeSBhbmQgbGVhZmxldCBhcmUgXCJpbXBvcnRlZFwiIGluIHRoZSBodG1sIHZpYSA8c2NyaXB0PlxuZGVjbGFyZSBsZXQgJDtcbmRlY2xhcmUgbGV0IEw7XG5cblxuLyoqXG4gKiBPcmNoZXN0cmF0ZSBpdCBhbGxcbiAqL1xuKGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAvLyB0aGUgbGVhZmxldCBsYXllciBvbiB3aGljaCB0aGUgY2lyY2xlcyBnZW5lcmF0ZWQgY2lyY2xlcyB3aWxsIGJlIGRyYXduXG4gICAgY29uc3QgY2lyY2xlc0xheWVyID0gbmV3IEwuRmVhdHVyZUdyb3VwKCkuYWRkVG8obWFwKTtcblxuICAgIC8vIHNldCBkZWZhdWx0IGNpcmNsZSByYWRpdXNcbiAgICAkKFwiI3JhZGl1cy1zaXplXCIpLmF0dHIoXCJ2YWx1ZVwiLCBERUZBVUxUX0NJUkNMRV9SQURJVVMpO1xuXG4gICAgLy8gYXR0YWNoIGEgY2FsbGJhY2sgdG8gdGhlIGV2ZW50IHdoZW4gYSB1c2VyIGhhcyBkcmF3biBhIHJlY3RhbmdsZSBvbiB0aGUgbWFwLlxuICAgIC8vIHRoZSBkZWZpbmluZyBjb29yZHMgb2YgdGhlIHJlY3RhbmdsZSBhcmUgdGhlbiBwYXNzZWQgdG8gYSBjYWxsYmFjayB0aGF0IHdlIHNldCBoZXJlXG4gICAgZW5hYmxlRHJhd2luZyhcbiAgICAgICAgb25DaXR5Qm91bmRhcnlSZWFkeS5iaW5kKG51bGwsIGNpcmNsZXNMYXllciksXG4gICAgICAgICgpID0+IGNpcmNsZXNMYXllci5jbGVhckxheWVycygpKTtcbn0pKCk7XG5cbi8qKlxuICogR2l2ZW4gYSBib3VuZGluZyByZWN0YW5nbGUgYW5kIGEgXCJjYW52YXNcIiwgZ2VuZXJhdGVkIHRoZSBjaXJjbGVzIGFuZCBmaWxsIHRoZSBjYW52YXMgd2l0aCB0aGVtXG4gKlxuICogQHBhcmFtIHtSZWN0YW5nbGV9IGJvdW5kaW5nUmVjdGFuZ2xlXG4gKiBAcGFyYW0gY2lyY2xlc0xheWVyIC0gdGhlIFwiY2FudmFzXCJcbiAqL1xuZnVuY3Rpb24gcmVnZW5lcmF0ZShib3VuZGluZ1JlY3RhbmdsZTogTC5SZWN0YW5nbGUsIGNpcmNsZXNMYXllcikge1xuICAgIC8vIHdpcGUgb3V0IGV4aXN0aW5nIGNpcmNsZXNcbiAgICBjaXJjbGVzTGF5ZXIuY2xlYXJMYXllcnMoKTtcblxuICAgIC8vIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZXMgdGhhdCB3aWxsIGZpbGwgdGhlIHJlY3RhbmdsZVxuICAgIGNvbnN0IGNpcmNsZV9yYWRpdXMgPSBnZXRVc2VyU2VsZWN0ZWRDaXJjbGVSYWRpdXMoKTsgLy8gbWV0cmVzXG4gICAgY29uc29sZS5sb2coYCR7Y2lyY2xlX3JhZGl1c31tIGNpcmNsZSByYWRpdXNgKTtcblxuICAgIC8vIGdlbmVyYXRlIGFsbCB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNpcmNsZXMgd2l0aGluIHRoZSBib3VuZGluZyBhcmVhXG4gICAgLy8gKm9ubHkqIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgKmNlbnRlciogb2YgdGhlIGNpcmNsZXMgaXMgcmV0dXJuZWRcbiAgICBjb25zdCBjb29yZHMgPSBjcmVhdGVDb29yZGluYXRlcyh7XG4gICAgICAgIGJvdW5kaW5nUmVjdGFuZ2xlOiBib3VuZGluZ1JlY3RhbmdsZSxcbiAgICAgICAgZGlzdGFuY2U6IGNpcmNsZV9yYWRpdXMgKiAyLFxuICAgIH0pO1xuICAgIC8vIC5tYWluICYgLmZpbGxlcnMgaXMgdXNlZCB0byBkZWJ1ZyBlYXNpbHkuIFRoZSB1bmlvbiBvZiB0aGUgdHdvIHNldHMgb2YgY2lyY2xlc1xuICAgIC8vIGlzIGluIC5jb21iaW5lZFxuICAgIGRyYXdDaXJjbGVzKGNvb3Jkcy5tYWluLCBjaXJjbGVzTGF5ZXIsIGNpcmNsZV9yYWRpdXMpO1xuICAgIGRyYXdDaXJjbGVzKGNvb3Jkcy5maWxsZXJzLCBjaXJjbGVzTGF5ZXIsIGNpcmNsZV9yYWRpdXMsIHtjb2xvcjogJ2dyZWVuJ30pO1xuXG4gICAgbGV0IGRvd25sb2FkQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkLWJ0bicpO1xuXG4gICAgY29uc29sZS5sb2coYEdlbmVyYXRlZCAke2Nvb3Jkcy5jb21iaW5lZC5sZW5ndGh9IGNpcmNsZXMgYCk7XG4gICAgZG93bmxvYWRCdG4ub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbncgPSBib3VuZGluZ1JlY3RhbmdsZS5nZXRCb3VuZHMoKS5nZXROb3J0aFdlc3QoKTtcbiAgICAgICAgY29uc3Qgc2UgPSBib3VuZGluZ1JlY3RhbmdsZS5nZXRCb3VuZHMoKS5nZXRTb3V0aEVhc3QoKTtcbiAgICAgICAgY29uc3QgYXJlYV9uYW1lID0gcHJvbXB0KFwiRW50ZXIgYXJlYSBuYW1lXCIsIFwiXCIpXG4gICAgICAgIGNvbnN0IHRvU2F2ZSA9IHtcbiAgICAgICAgICAgIGFyZWFfbmFtZTogYXJlYV9uYW1lLFxuICAgICAgICAgICAgY2lyY2xlX3JhZGl1czogY2lyY2xlX3JhZGl1cyxcbiAgICAgICAgICAgIGJvdW5kaW5nX3JlY3RhbmdsZToge1xuICAgICAgICAgICAgICAgIG5vcnRod2VzdDoge2xhdDogbncubGF0LCBsbmc6IG53LmxuZ30sXG4gICAgICAgICAgICAgICAgc291dGhlYXN0OiB7bGF0OiBzZS5sYXQsIGxuZzogc2UubG5nfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRzLmNvbWJpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBzYXZlRmlsZShKU09OLnN0cmluZ2lmeSh0b1NhdmUpLCBgJHthcmVhX25hbWV9X2Nvb3Jkc18ke3RvU2F2ZS5jb29yZGluYXRlcy5sZW5ndGh9X3Ike2NpcmNsZV9yYWRpdXN9Lmpzb25gLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgIH07XG59XG5cblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBoYXMgZHJhd24gYSByZWN0YW5nbGVcbiAqIEBwYXJhbSBjaXJjbGVzTGF5ZXIgdGhlIGxheWVyIG9uIHdoaWNoIHdlIHdhbnQgdG8gZHJhdyB0aGUgZ2VuZXJhdGVkIGNpcmNsZXNcbiAqIEBwYXJhbSB7TGF0TG5nW119IGRyYXduUmVjdGFuZ2xlXG4gKi9cbmZ1bmN0aW9uIG9uQ2l0eUJvdW5kYXJ5UmVhZHkoY2lyY2xlc0xheWVyLCBkcmF3blJlY3RhbmdsZTogTC5SZWN0YW5nbGUpIHtcbiAgICBjaXJjbGVzTGF5ZXIuY2xlYXJMYXllcnMoKTtcblxuICAgIGNvbnN0IHJlZHJhd0J0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWdlbmVyYXRlLWJ0bicpO1xuICAgIHJlZHJhd0J0bi5vbmNsaWNrID0gcmVnZW5lcmF0ZS5iaW5kKG51bGwsIGRyYXduUmVjdGFuZ2xlLCBjaXJjbGVzTGF5ZXIpO1xuICAgIHJlZHJhd0J0bi5jbGljaygpO1xufVxuXG5mdW5jdGlvbiBnZXRVc2VyU2VsZWN0ZWRDaXJjbGVSYWRpdXMoKSB7XG4gICAgcmV0dXJuIE51bWJlcigkKFwiI3JhZGl1cy1zaXplXCIpLnZhbCgpKTtcbn1cblxuXG4vKipcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMzU0MjQ5OVxuICogU2F2ZSBhIGZpbGUgdG8gdGhlIGxvY2FsIGZpbGVzeXN0ZW1cbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gZmlsZW5hbWVcbiAqIEBwYXJhbSBjb250ZW50VHlwZVxuICovXG5mdW5jdGlvbiBzYXZlRmlsZShkYXRhLCBmaWxlbmFtZSwgY29udGVudFR5cGUpIHtcbiAgICBsZXQgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge3R5cGU6IGNvbnRlbnRUeXBlfSk7XG4gICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZUJsb2IoYmxvYiwgZmlsZW5hbWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGVsZW0gPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBlbGVtLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgZWxlbS5kb3dubG9hZCA9IGZpbGVuYW1lO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICBlbGVtLmNsaWNrKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgfVxufVxuXG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQU9BOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/app.ts\n");

/***/ }),

/***/ "./src/core.ts":
/*!*********************!*\
  !*** ./src/core.ts ***!
  \*********************/
/*! exports provided: DEFAULT_CIRCLE_RADIUS, createCoordinates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_CIRCLE_RADIUS\", function() { return DEFAULT_CIRCLE_RADIUS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createCoordinates\", function() { return createCoordinates; });\n/* harmony import */ var _geo_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geo_utils */ \"./src/geo_utils.ts\");\n\nvar DEFAULT_CIRCLE_RADIUS = 150; // meters\n/**\n * This function is the core of the whole repo.\n *\n * The function receives createCoordinatesReturn rectangle and wants to figure out\n * the coordinates of the centers of circles, such that the circles fill out the whole rectangle.\n * We allow for the circles to overlap.\n *\n * All circles discussed below have the same radius (R = @options.dist/2).\n *\n * The function \"iterates\" the rectangle from west-to-east, north-to-south.\n * A row is createCoordinatesReturn \"line\" from west-to-east.\n *\n * On each row the circles are next to each other, without overlapping (i.e. 0 distance b/w circles on createCoordinatesReturn row)\n * There's no distance between circles on adjacent columns too.\n * This means that these \"main\" circles will not fill up the whole rectangle.\n *\n * Thus, between each two adjacent \"main\" rows (e.g. rows A and B)  we insert createCoordinatesReturn filler row (F).\n * Row F is effectively copy of A but shifted first south and then east by the radius R. The last element of the filler\n * row is removed since it's too far from the east end of the bounding rectangle.\n *\n * @param {createCoordinatesOpts} options. .dist is the distance between the centers of two circles. i.e. it is the radius of createCoordinatesReturn circle\n * @return {createCoordinatesReturn}\n */\nfunction createCoordinates(options) {\n    var result = [], fillers = [];\n    var rectBounds = options.boundingRectangle.getBounds();\n    var initialPoint = Object.freeze(rectBounds.getNorthWest());\n    var currentCoord = initialPoint;\n    var currentRowInitial = currentCoord;\n    for (var row = 1;; row++) {\n        var currentRowCirclesCoords = circleCoordsOfRow(rectBounds, currentRowInitial, options.distance);\n        result.push.apply(result, currentRowCirclesCoords);\n        var fillerFirstCoord = moveToSouthEast(currentRowInitial, options.distance);\n        if (!Object(_geo_utils__WEBPACK_IMPORTED_MODULE_0__[\"isWithinBounds\"])([rectBounds.getNorth(), rectBounds.getSouth()], currentCoord.lat)) {\n            break;\n        }\n        else {\n            var helperRowCoords = circleCoordsOfRow(rectBounds, fillerFirstCoord, options.distance);\n            helperRowCoords.pop();\n            fillers.push.apply(fillers, helperRowCoords);\n        }\n        currentRowInitial = currentCoord = Object(_geo_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateNextPoint\"])(initialPoint, options.distance * row, Bearing.south).point;\n    }\n    return { main: result, fillers: fillers, combined: result.concat(fillers) };\n}\n/**\n * (generates rows for createCoordinates())\n * Generate the coordinates of circles on createCoordinatesReturn generic row (i.e. used for both \"main\"/\"filler\" rows).\n *\n * The function starts from createCoordinatesReturn given @initialCoord and moves east. On each iteration it checks if the current\n * coordinate is within the longitude bounds of the rect (i.e. at most one circle beyond the east side of the rect).\n * If it's beyond - the function returns the row. Since we add to the result before we make the bound check,\n * we allow for at most one circle beyond the bounds.\n *\n * @param {LatLngBounds} bounds - the bounds of the big rectangle around the city\n * @param {LatLng} initialCoord - where is the centre of the first circle on that row\n * @param distance - the distance between the centers of two adjacent circles on this row\n * @return {LatLng[]} the coordinates of the centers of all circles on this row\n */\nfunction circleCoordsOfRow(bounds, initialCoord, distance) {\n    var eastBound = bounds.getEast();\n    var result = [];\n    var currentPosition = initialCoord;\n    for (;;) {\n        result.push(currentPosition);\n        /*\n        use initialCoord.lng instead of \"westBound\" because of createCoordinatesReturn numerical error propagated up from calculateNextPoint().\n        the error increases the more we go south from the north-west point of @bounds.\n\n        tl;dr it's due to the fact that the earth has an imperfect shape\n        */\n        if (!Object(_geo_utils__WEBPACK_IMPORTED_MODULE_0__[\"isWithinBounds\"])([initialCoord.lng, eastBound], currentPosition.lng)) {\n            break;\n        }\n        currentPosition = Object(_geo_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateNextPoint\"])(currentPosition, distance, Bearing.east).point;\n    }\n    return result;\n}\nfunction moveToSouthEast(currentRowInitial, dist) {\n    var shiftSouth = Object(_geo_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateNextPoint\"])(currentRowInitial, dist / 2, Bearing.south).point;\n    return Object(_geo_utils__WEBPACK_IMPORTED_MODULE_0__[\"calculateNextPoint\"])(shiftSouth, dist / 2, Bearing.east).point;\n}\n// i.e. direction\nvar Bearing;\n(function (Bearing) {\n    Bearing[Bearing[\"east\"] = 90] = \"east\";\n    Bearing[Bearing[\"west\"] = -90] = \"west\";\n    Bearing[Bearing[\"north\"] = 0] = \"north\";\n    Bearing[Bearing[\"south\"] = 180] = \"south\";\n})(Bearing || (Bearing = {}));\nvar RectangleSide;\n(function (RectangleSide) {\n    // todo add others\n    RectangleSide[\"northWest\"] = \"NorthWest\";\n})(RectangleSide || (RectangleSide = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29yZS50cy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb3JlLnRzPzY5OWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtjYWxjdWxhdGVOZXh0UG9pbnQsIGlzV2l0aGluQm91bmRzfSBmcm9tIFwiLi9nZW9fdXRpbHNcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0lSQ0xFX1JBRElVUyA9IDE1MDsgLy8gbWV0ZXJzXG5kZWNsYXJlIGxldCBMO1xuXG50eXBlIGNyZWF0ZUNvb3JkaW5hdGVzT3B0cyA9IHtcbiAgICBib3VuZGluZ1JlY3RhbmdsZTogTC5SZWN0YW5nbGUsXG4gICAgZGlzdGFuY2U6IG51bWJlcixcbn1cbnR5cGUgY3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4gPSB7IG1haW46IEwuTGF0TG5nW10sIGZpbGxlcnM6IEwuTGF0TG5nW10sIGNvbWJpbmVkOiBMLkxhdExuZ1tdIH07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0aGUgY29yZSBvZiB0aGUgd2hvbGUgcmVwby5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgY3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4gcmVjdGFuZ2xlIGFuZCB3YW50cyB0byBmaWd1cmUgb3V0XG4gKiB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlcnMgb2YgY2lyY2xlcywgc3VjaCB0aGF0IHRoZSBjaXJjbGVzIGZpbGwgb3V0IHRoZSB3aG9sZSByZWN0YW5nbGUuXG4gKiBXZSBhbGxvdyBmb3IgdGhlIGNpcmNsZXMgdG8gb3ZlcmxhcC5cbiAqXG4gKiBBbGwgY2lyY2xlcyBkaXNjdXNzZWQgYmVsb3cgaGF2ZSB0aGUgc2FtZSByYWRpdXMgKFIgPSBAb3B0aW9ucy5kaXN0LzIpLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBcIml0ZXJhdGVzXCIgdGhlIHJlY3RhbmdsZSBmcm9tIHdlc3QtdG8tZWFzdCwgbm9ydGgtdG8tc291dGguXG4gKiBBIHJvdyBpcyBjcmVhdGVDb29yZGluYXRlc1JldHVybiBcImxpbmVcIiBmcm9tIHdlc3QtdG8tZWFzdC5cbiAqXG4gKiBPbiBlYWNoIHJvdyB0aGUgY2lyY2xlcyBhcmUgbmV4dCB0byBlYWNoIG90aGVyLCB3aXRob3V0IG92ZXJsYXBwaW5nIChpLmUuIDAgZGlzdGFuY2UgYi93IGNpcmNsZXMgb24gY3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4gcm93KVxuICogVGhlcmUncyBubyBkaXN0YW5jZSBiZXR3ZWVuIGNpcmNsZXMgb24gYWRqYWNlbnQgY29sdW1ucyB0b28uXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlc2UgXCJtYWluXCIgY2lyY2xlcyB3aWxsIG5vdCBmaWxsIHVwIHRoZSB3aG9sZSByZWN0YW5nbGUuXG4gKlxuICogVGh1cywgYmV0d2VlbiBlYWNoIHR3byBhZGphY2VudCBcIm1haW5cIiByb3dzIChlLmcuIHJvd3MgQSBhbmQgQikgIHdlIGluc2VydCBjcmVhdGVDb29yZGluYXRlc1JldHVybiBmaWxsZXIgcm93IChGKS5cbiAqIFJvdyBGIGlzIGVmZmVjdGl2ZWx5IGNvcHkgb2YgQSBidXQgc2hpZnRlZCBmaXJzdCBzb3V0aCBhbmQgdGhlbiBlYXN0IGJ5IHRoZSByYWRpdXMgUi4gVGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgZmlsbGVyXG4gKiByb3cgaXMgcmVtb3ZlZCBzaW5jZSBpdCdzIHRvbyBmYXIgZnJvbSB0aGUgZWFzdCBlbmQgb2YgdGhlIGJvdW5kaW5nIHJlY3RhbmdsZS5cbiAqXG4gKiBAcGFyYW0ge2NyZWF0ZUNvb3JkaW5hdGVzT3B0c30gb3B0aW9ucy4gLmRpc3QgaXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnMgb2YgdHdvIGNpcmNsZXMuIGkuZS4gaXQgaXMgdGhlIHJhZGl1cyBvZiBjcmVhdGVDb29yZGluYXRlc1JldHVybiBjaXJjbGVcbiAqIEByZXR1cm4ge2NyZWF0ZUNvb3JkaW5hdGVzUmV0dXJufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29vcmRpbmF0ZXMob3B0aW9uczogY3JlYXRlQ29vcmRpbmF0ZXNPcHRzKTogY3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4ge1xuICAgIGNvbnN0IHJlc3VsdDogTC5MYXRMbmdbXSA9IFtdLCBmaWxsZXJzOiBMLkxhdExuZ1tdID0gW107XG5cbiAgICBjb25zdCByZWN0Qm91bmRzID0gb3B0aW9ucy5ib3VuZGluZ1JlY3RhbmdsZS5nZXRCb3VuZHMoKTtcbiAgICBjb25zdCBpbml0aWFsUG9pbnQgPSBPYmplY3QuZnJlZXplKHJlY3RCb3VuZHMuZ2V0Tm9ydGhXZXN0KCkpO1xuXG4gICAgbGV0IGN1cnJlbnRDb29yZDogTC5MYXRMbmcgPSBpbml0aWFsUG9pbnQ7XG4gICAgbGV0IGN1cnJlbnRSb3dJbml0aWFsID0gY3VycmVudENvb3JkO1xuICAgIGZvciAobGV0IHJvdyA9IDE7IDsgcm93KyspIHtcblxuICAgICAgICBsZXQgY3VycmVudFJvd0NpcmNsZXNDb29yZHMgPSBjaXJjbGVDb29yZHNPZlJvdyhyZWN0Qm91bmRzLCBjdXJyZW50Um93SW5pdGlhbCwgb3B0aW9ucy5kaXN0YW5jZSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmN1cnJlbnRSb3dDaXJjbGVzQ29vcmRzKTtcblxuICAgICAgICBsZXQgZmlsbGVyRmlyc3RDb29yZCA9IG1vdmVUb1NvdXRoRWFzdChjdXJyZW50Um93SW5pdGlhbCwgb3B0aW9ucy5kaXN0YW5jZSk7XG5cbiAgICAgICAgaWYgKCFpc1dpdGhpbkJvdW5kcyhbcmVjdEJvdW5kcy5nZXROb3J0aCgpLCByZWN0Qm91bmRzLmdldFNvdXRoKCldLCBjdXJyZW50Q29vcmQubGF0KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgaGVscGVyUm93Q29vcmRzOiBMLkxhdExuZ1tdID0gY2lyY2xlQ29vcmRzT2ZSb3cocmVjdEJvdW5kcywgZmlsbGVyRmlyc3RDb29yZCwgb3B0aW9ucy5kaXN0YW5jZSk7XG4gICAgICAgICAgICBoZWxwZXJSb3dDb29yZHMucG9wKCk7XG4gICAgICAgICAgICBmaWxsZXJzLnB1c2goLi4uaGVscGVyUm93Q29vcmRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRSb3dJbml0aWFsID0gY3VycmVudENvb3JkID0gY2FsY3VsYXRlTmV4dFBvaW50KGluaXRpYWxQb2ludCwgb3B0aW9ucy5kaXN0YW5jZSAqIHJvdywgQmVhcmluZy5zb3V0aCkucG9pbnQ7XG4gICAgfVxuICAgIHJldHVybiB7bWFpbjogcmVzdWx0LCBmaWxsZXJzOiBmaWxsZXJzLCBjb21iaW5lZDogcmVzdWx0LmNvbmNhdChmaWxsZXJzKX1cblxufVxuXG4vKipcbiAqIChnZW5lcmF0ZXMgcm93cyBmb3IgY3JlYXRlQ29vcmRpbmF0ZXMoKSlcbiAqIEdlbmVyYXRlIHRoZSBjb29yZGluYXRlcyBvZiBjaXJjbGVzIG9uIGNyZWF0ZUNvb3JkaW5hdGVzUmV0dXJuIGdlbmVyaWMgcm93IChpLmUuIHVzZWQgZm9yIGJvdGggXCJtYWluXCIvXCJmaWxsZXJcIiByb3dzKS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gc3RhcnRzIGZyb20gY3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4gZ2l2ZW4gQGluaXRpYWxDb29yZCBhbmQgbW92ZXMgZWFzdC4gT24gZWFjaCBpdGVyYXRpb24gaXQgY2hlY2tzIGlmIHRoZSBjdXJyZW50XG4gKiBjb29yZGluYXRlIGlzIHdpdGhpbiB0aGUgbG9uZ2l0dWRlIGJvdW5kcyBvZiB0aGUgcmVjdCAoaS5lLiBhdCBtb3N0IG9uZSBjaXJjbGUgYmV5b25kIHRoZSBlYXN0IHNpZGUgb2YgdGhlIHJlY3QpLlxuICogSWYgaXQncyBiZXlvbmQgLSB0aGUgZnVuY3Rpb24gcmV0dXJucyB0aGUgcm93LiBTaW5jZSB3ZSBhZGQgdG8gdGhlIHJlc3VsdCBiZWZvcmUgd2UgbWFrZSB0aGUgYm91bmQgY2hlY2ssXG4gKiB3ZSBhbGxvdyBmb3IgYXQgbW9zdCBvbmUgY2lyY2xlIGJleW9uZCB0aGUgYm91bmRzLlxuICpcbiAqIEBwYXJhbSB7TGF0TG5nQm91bmRzfSBib3VuZHMgLSB0aGUgYm91bmRzIG9mIHRoZSBiaWcgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgY2l0eVxuICogQHBhcmFtIHtMYXRMbmd9IGluaXRpYWxDb29yZCAtIHdoZXJlIGlzIHRoZSBjZW50cmUgb2YgdGhlIGZpcnN0IGNpcmNsZSBvbiB0aGF0IHJvd1xuICogQHBhcmFtIGRpc3RhbmNlIC0gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNlbnRlcnMgb2YgdHdvIGFkamFjZW50IGNpcmNsZXMgb24gdGhpcyByb3dcbiAqIEByZXR1cm4ge0xhdExuZ1tdfSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlcnMgb2YgYWxsIGNpcmNsZXMgb24gdGhpcyByb3dcbiAqL1xuZnVuY3Rpb24gY2lyY2xlQ29vcmRzT2ZSb3coYm91bmRzOiBMLkxhdExuZ0JvdW5kcywgaW5pdGlhbENvb3JkOiBMLkxhdExuZywgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBlYXN0Qm91bmQgPSBib3VuZHMuZ2V0RWFzdCgpO1xuXG4gICAgbGV0IHJlc3VsdDogTC5MYXRMbmdbXSA9IFtdO1xuICAgIGxldCBjdXJyZW50UG9zaXRpb246IEwuTGF0TG5nID0gaW5pdGlhbENvb3JkO1xuICAgIGZvciAoOyA7KSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQb3NpdGlvbik7XG4gICAgICAgIC8qXG4gICAgICAgIHVzZSBpbml0aWFsQ29vcmQubG5nIGluc3RlYWQgb2YgXCJ3ZXN0Qm91bmRcIiBiZWNhdXNlIG9mIGNyZWF0ZUNvb3JkaW5hdGVzUmV0dXJuIG51bWVyaWNhbCBlcnJvciBwcm9wYWdhdGVkIHVwIGZyb20gY2FsY3VsYXRlTmV4dFBvaW50KCkuXG4gICAgICAgIHRoZSBlcnJvciBpbmNyZWFzZXMgdGhlIG1vcmUgd2UgZ28gc291dGggZnJvbSB0aGUgbm9ydGgtd2VzdCBwb2ludCBvZiBAYm91bmRzLlxuXG4gICAgICAgIHRsO2RyIGl0J3MgZHVlIHRvIHRoZSBmYWN0IHRoYXQgdGhlIGVhcnRoIGhhcyBhbiBpbXBlcmZlY3Qgc2hhcGVcbiAgICAgICAgKi9cbiAgICAgICAgaWYgKCFpc1dpdGhpbkJvdW5kcyhbaW5pdGlhbENvb3JkLmxuZywgZWFzdEJvdW5kXSwgY3VycmVudFBvc2l0aW9uLmxuZykpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBvc2l0aW9uID0gY2FsY3VsYXRlTmV4dFBvaW50KGN1cnJlbnRQb3NpdGlvbiwgZGlzdGFuY2UsIEJlYXJpbmcuZWFzdCkucG9pbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW92ZVRvU291dGhFYXN0KGN1cnJlbnRSb3dJbml0aWFsLCBkaXN0KSB7XG4gICAgbGV0IHNoaWZ0U291dGggPSBjYWxjdWxhdGVOZXh0UG9pbnQoY3VycmVudFJvd0luaXRpYWwsIGRpc3QgLyAyLCBCZWFyaW5nLnNvdXRoKS5wb2ludDtcbiAgICByZXR1cm4gY2FsY3VsYXRlTmV4dFBvaW50KHNoaWZ0U291dGgsIGRpc3QgLyAyLCBCZWFyaW5nLmVhc3QpLnBvaW50O1xufVxuXG4vLyBpLmUuIGRpcmVjdGlvblxuZW51bSBCZWFyaW5nIHtcbiAgICBlYXN0ID0gOTAsXG4gICAgd2VzdCA9IC05MCxcblxuICAgIG5vcnRoID0gMCxcbiAgICBzb3V0aCA9IDE4MFxufVxuXG5lbnVtIFJlY3RhbmdsZVNpZGUge1xuICAgIC8vIHRvZG8gYWRkIG90aGVyc1xuICAgIG5vcnRoV2VzdCA9IFwiTm9ydGhXZXN0XCJcbn1cblxuXG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBO0FBU0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBOzs7Ozs7Ozs7Ozs7O0FBYUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/core.ts\n");

/***/ }),

/***/ "./src/geo_utils.ts":
/*!**************************!*\
  !*** ./src/geo_utils.ts ***!
  \**************************/
/*! exports provided: calculateNextPoint, isWithinBounds */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateNextPoint\", function() { return calculateNextPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWithinBounds\", function() { return isWithinBounds; });\nvar EARTH_RADIUS = 6371e3;\n/**\n * \"Destination point given distance and bearing from start point\"\n * i.e. given a point (lat,lng), direction and distance, calculate the destination coordinates\n * Credits: http://www.movable-type.co.uk/scripts/latlong.html\n *\n * @param coordinate : the start point\n * @param {number} distance, in metres\n * @param {number} bearing - direction, in degrees from north clockwise\n * @return the new point and the new bearing\n * */\nfunction calculateNextPoint(coordinate, distance, bearing) {\n    if (distance === void 0) { distance = 500; }\n    var delta = Number(distance) / EARTH_RADIUS; // angular distance in radians\n    var theta = toRadians(Number(bearing));\n    var phi1 = toRadians(coordinate.lat);\n    var lambda1 = toRadians(coordinate.lng);\n    var sinphi1 = Math.sin(phi1), cosphi1 = Math.cos(phi1);\n    var sindelta = Math.sin(delta), cosdelta = Math.cos(delta);\n    var sintheta = Math.sin(theta), costheta = Math.cos(theta);\n    var sinphi2 = sinphi1 * cosdelta + cosphi1 * sindelta * costheta;\n    var phi2 = Math.asin(sinphi2);\n    var y = sintheta * sindelta * cosphi1;\n    var x = cosdelta - sinphi1 * sinphi2;\n    var lambda2 = lambda1 + Math.atan2(y, x);\n    var destinationPoint = L.latLng(toDegrees(phi2), (toDegrees(lambda2) + 540) % 360 - 180); // normalise to −180..+180°,\n    return {\n        point: destinationPoint\n    };\n}\n/**\n * `num` is a latitude/longitude coordinate and `bounds` is a line.\n * This method checks if `num` is within this line.\n * E.g. we have a line that goes from north to south - from [lat:40 lng:30] to [lat:40 lng:20] and we want to check if\n * lng:25 is within the bounds of the line.\n * when using this method the bounds would be [30,20] and num=25.\n *\n * @param {[number , number]} bounds\n * @param {number} num\n * @return {boolean}\n */\nfunction isWithinBounds(bounds, num) {\n    var minLat = Math.min.apply(Math, bounds), maxLat = Math.max.apply(Math, bounds);\n    return (minLat <= num) && (num <= maxLat);\n}\nfunction toRadians(num) {\n    return num * Math.PI / 180;\n}\nfunction toDegrees(num) {\n    return num * 180 / Math.PI;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZ2VvX3V0aWxzLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL2dlb191dGlscy50cz82ZWRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgQ3JlZGl0czogaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbiAqIC0+IGxhdGxvbi1zcGhlcmljYWwuanNcbiAqL1xuZGVjbGFyZSBsZXQgTDtcbmNvbnN0IEVBUlRIX1JBRElVUyA9IDYzNzFlMztcblxuLyoqXG4gKiBcIkRlc3RpbmF0aW9uIHBvaW50IGdpdmVuIGRpc3RhbmNlIGFuZCBiZWFyaW5nIGZyb20gc3RhcnQgcG9pbnRcIlxuICogaS5lLiBnaXZlbiBhIHBvaW50IChsYXQsbG5nKSwgZGlyZWN0aW9uIGFuZCBkaXN0YW5jZSwgY2FsY3VsYXRlIHRoZSBkZXN0aW5hdGlvbiBjb29yZGluYXRlc1xuICogQ3JlZGl0czogaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbiAqXG4gKiBAcGFyYW0gY29vcmRpbmF0ZSA6IHRoZSBzdGFydCBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlLCBpbiBtZXRyZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIC0gZGlyZWN0aW9uLCBpbiBkZWdyZWVzIGZyb20gbm9ydGggY2xvY2t3aXNlXG4gKiBAcmV0dXJuIHRoZSBuZXcgcG9pbnQgYW5kIHRoZSBuZXcgYmVhcmluZ1xuICogKi9cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVOZXh0UG9pbnQoY29vcmRpbmF0ZTogTC5MYXRMbmcsIGRpc3RhbmNlID0gNTAwLCBiZWFyaW5nKTogeyBwb2ludDogTC5MYXRMbmd9IHtcblxuICAgIGxldCBkZWx0YSA9IE51bWJlcihkaXN0YW5jZSkgLyBFQVJUSF9SQURJVVM7IC8vIGFuZ3VsYXIgZGlzdGFuY2UgaW4gcmFkaWFuc1xuICAgIGxldCB0aGV0YSA9IHRvUmFkaWFucyhOdW1iZXIoYmVhcmluZykpO1xuXG4gICAgbGV0IHBoaTEgPSB0b1JhZGlhbnMoY29vcmRpbmF0ZS5sYXQpO1xuICAgIGxldCBsYW1iZGExID0gdG9SYWRpYW5zKGNvb3JkaW5hdGUubG5nKTtcblxuICAgIGxldCBzaW5waGkxID0gTWF0aC5zaW4ocGhpMSksIGNvc3BoaTEgPSBNYXRoLmNvcyhwaGkxKTtcbiAgICBsZXQgc2luZGVsdGEgPSBNYXRoLnNpbihkZWx0YSksIGNvc2RlbHRhID0gTWF0aC5jb3MoZGVsdGEpO1xuICAgIGxldCBzaW50aGV0YSA9IE1hdGguc2luKHRoZXRhKSwgY29zdGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgICBsZXQgc2lucGhpMiA9IHNpbnBoaTEgKiBjb3NkZWx0YSArIGNvc3BoaTEgKiBzaW5kZWx0YSAqIGNvc3RoZXRhO1xuICAgIGxldCBwaGkyID0gTWF0aC5hc2luKHNpbnBoaTIpO1xuICAgIGxldCB5ID0gc2ludGhldGEgKiBzaW5kZWx0YSAqIGNvc3BoaTE7XG4gICAgbGV0IHggPSBjb3NkZWx0YSAtIHNpbnBoaTEgKiBzaW5waGkyO1xuICAgIGxldCBsYW1iZGEyID0gbGFtYmRhMSArIE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgICBjb25zdCBkZXN0aW5hdGlvblBvaW50ID0gTC5sYXRMbmcodG9EZWdyZWVzKHBoaTIpLCAodG9EZWdyZWVzKGxhbWJkYTIpICsgNTQwKSAlIDM2MCAtIDE4MCk7IC8vIG5vcm1hbGlzZSB0byDiiJIxODAuLisxODDCsCxcblxuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBkZXN0aW5hdGlvblBvaW50XG4gICAgfVxufVxuXG4vKipcbiAqIGBudW1gIGlzIGEgbGF0aXR1ZGUvbG9uZ2l0dWRlIGNvb3JkaW5hdGUgYW5kIGBib3VuZHNgIGlzIGEgbGluZS5cbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBgbnVtYCBpcyB3aXRoaW4gdGhpcyBsaW5lLlxuICogRS5nLiB3ZSBoYXZlIGEgbGluZSB0aGF0IGdvZXMgZnJvbSBub3J0aCB0byBzb3V0aCAtIGZyb20gW2xhdDo0MCBsbmc6MzBdIHRvIFtsYXQ6NDAgbG5nOjIwXSBhbmQgd2Ugd2FudCB0byBjaGVjayBpZlxuICogbG5nOjI1IGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBsaW5lLlxuICogd2hlbiB1c2luZyB0aGlzIG1ldGhvZCB0aGUgYm91bmRzIHdvdWxkIGJlIFszMCwyMF0gYW5kIG51bT0yNS5cbiAqXG4gKiBAcGFyYW0ge1tudW1iZXIgLCBudW1iZXJdfSBib3VuZHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1dpdGhpbkJvdW5kcyhib3VuZHM6IFtudW1iZXIsIG51bWJlcl0sIG51bTogbnVtYmVyKSB7XG4gICAgbGV0IG1pbkxhdCA9IE1hdGgubWluKC4uLmJvdW5kcyksIG1heExhdCA9IE1hdGgubWF4KC4uLmJvdW5kcyk7XG4gICAgcmV0dXJuIChtaW5MYXQgPD0gbnVtKSAmJiAobnVtIDw9IG1heExhdCk7XG59XG5cbmZ1bmN0aW9uIHRvUmFkaWFucyhudW0pIHtcbiAgICByZXR1cm4gbnVtICogTWF0aC5QSSAvIDE4MFxufVxuXG5mdW5jdGlvbiB0b0RlZ3JlZXMobnVtKSB7XG4gICAgcmV0dXJuIG51bSAqIDE4MCAvIE1hdGguUElcbn1cblxuXG5cblxuIl0sIm1hcHBpbmdzIjoiQUFLQTtBQUFBO0FBQUE7QUFBQTtBQUVBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/geo_utils.ts\n");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/*! exports provided: map, layerForUserRectangles, enableDrawing, drawCircles */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"map\", function() { return map; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"layerForUserRectangles\", function() { return layerForUserRectangles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"enableDrawing\", function() { return enableDrawing; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"drawCircles\", function() { return drawCircles; });\nvar __assign = (undefined && undefined.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar map;\nvar layerForUserRectangles;\n// add the map to the page\nmap = L.map('map').setView([42.697930, 23.321628], 13);\nL.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token={accessToken}', {\n    attribution: 'Map data &copy; <createCoordinatesReturn href=\"http://openstreetmap.org\">OpenStreetMap</createCoordinatesReturn> contributors, <createCoordinatesReturn href=\"http://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</createCoordinatesReturn>, Imagery © <createCoordinatesReturn href=\"http://mapbox.com\">Mapbox</createCoordinatesReturn>',\n    maxZoom: 18,\n    id: 'mapbox.streets-basic',\n    accessToken: 'pk.eyJ1IjoiY2hpcHNhbiIsImEiOiJqa0JwV1pnIn0.mvduWzyRdcHxK_QIOpetFg'\n}).addTo(map);\n// the collapsible sidebar with redraw/download etc. custom buttons\nvar sidebar = L.control.sidebar('sidebar').addTo(map);\n// where we draw rectangles\nlayerForUserRectangles = new L.FeatureGroup();\nmap.addLayer(layerForUserRectangles);\n// enable the plugin for drawing on the map\nvar drawControl = new L.Control.Draw({\n    edit: {\n        featureGroup: layerForUserRectangles\n    },\n    draw: {\n        circle: false,\n        circlemarker: false,\n        marker: false,\n        polygon: false,\n        polyline: false,\n    }\n});\nmap.addControl(drawControl);\n/**\n * A function which collects what the user has drawn and pass it to a callback\n * @param {(rectangle: Rectangle) => any} callbackOnRectDrawn\n * @param {() => void} callbackOnDelete\n */\nfunction enableDrawing(callbackOnRectDrawn, callbackOnDelete) {\n    // todo handle \"edited\" too\n    map.on('draw:created', function (e) {\n        var type = e.layerType, layer = e.layer;\n        if (type !== \"rectangle\") {\n            return true;\n        }\n        layerForUserRectangles.clearLayers();\n        console.log(type + \" drawn\");\n        var latlngs = layer.getLatLngs()[0];\n        layerForUserRectangles.addLayer(layer);\n        console.log(\"Boundaries of the area of interest:\");\n        console.log(JSON.stringify(latlngs));\n        // prepare the result to be used for constructing a rectangle\n        var rectangleBounds = L.latLngBounds(latlngs.map(function (coord) {\n            return [coord.lat, coord.lng];\n        }));\n        // make the rectangle, which encompasses the area which we want to fill with circles\n        var boundingRectangle = L.rectangle(rectangleBounds);\n        // pass the rectangle to the callback\n        callbackOnRectDrawn(boundingRectangle);\n    });\n    map.on(\"draw:deleted\", callbackOnDelete);\n}\nvar myRenderer = L.canvas({ padding: 0.5 });\n/**\n * Given a layer, coordinates of the center of circles and the radius of the circle,\n * draw the circles on the layer\n * @param {LatLng[]} coords\n * @param {LayerGroup} layer\n * @param {number} circleRadius\n * @param {{}} circleOptions\n */\nfunction drawCircles(coords, layer, circleRadius, circleOptions) {\n    if (circleRadius === void 0) { circleRadius = 300; }\n    if (circleOptions === void 0) { circleOptions = {}; }\n    var opts = __assign({ color: \"red\" }, circleOptions);\n    coords.forEach(function (coord) {\n        L.circle(coord, { radius: circleRadius }, circleOptions).addTo(layer);\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFwLnRzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21hcC50cz8yOGE0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBsZXQgbWFwO1xuZXhwb3J0IGxldCBsYXllckZvclVzZXJSZWN0YW5nbGVzO1xuZGVjbGFyZSBsZXQgTDtcbi8vIGFkZCB0aGUgbWFwIHRvIHRoZSBwYWdlXG5tYXAgPSBMLm1hcCgnbWFwJykuc2V0VmlldyhbNDIuNjk3OTMwLCAyMy4zMjE2MjhdLCAxMyk7XG5MLnRpbGVMYXllcignaHR0cHM6Ly9hcGkudGlsZXMubWFwYm94LmNvbS92NC97aWR9L3t6fS97eH0ve3l9LnBuZz9hY2Nlc3NfdG9rZW49e2FjY2Vzc1Rva2VufScsIHtcbiAgICBhdHRyaWJ1dGlvbjogJ01hcCBkYXRhICZjb3B5OyA8Y3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4gaHJlZj1cImh0dHA6Ly9vcGVuc3RyZWV0bWFwLm9yZ1wiPk9wZW5TdHJlZXRNYXA8L2NyZWF0ZUNvb3JkaW5hdGVzUmV0dXJuPiBjb250cmlidXRvcnMsIDxjcmVhdGVDb29yZGluYXRlc1JldHVybiBocmVmPVwiaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktc2EvMi4wL1wiPkNDLUJZLVNBPC9jcmVhdGVDb29yZGluYXRlc1JldHVybj4sIEltYWdlcnkgwqkgPGNyZWF0ZUNvb3JkaW5hdGVzUmV0dXJuIGhyZWY9XCJodHRwOi8vbWFwYm94LmNvbVwiPk1hcGJveDwvY3JlYXRlQ29vcmRpbmF0ZXNSZXR1cm4+JyxcbiAgICBtYXhab29tOiAxOCxcbiAgICBpZDogJ21hcGJveC5zdHJlZXRzLWJhc2ljJyxcbiAgICBhY2Nlc3NUb2tlbjogJ3BrLmV5SjFJam9pWTJocGNITmhiaUlzSW1FaU9pSnFhMEp3VjFwbkluMC5tdmR1V3p5UmRjSHhLX1FJT3BldEZnJ1xufSkuYWRkVG8obWFwKTtcblxuXG4vLyB0aGUgY29sbGFwc2libGUgc2lkZWJhciB3aXRoIHJlZHJhdy9kb3dubG9hZCBldGMuIGN1c3RvbSBidXR0b25zXG5sZXQgc2lkZWJhciA9IEwuY29udHJvbC5zaWRlYmFyKCdzaWRlYmFyJykuYWRkVG8obWFwKTtcblxuLy8gd2hlcmUgd2UgZHJhdyByZWN0YW5nbGVzXG5sYXllckZvclVzZXJSZWN0YW5nbGVzID0gbmV3IEwuRmVhdHVyZUdyb3VwKCk7XG5tYXAuYWRkTGF5ZXIobGF5ZXJGb3JVc2VyUmVjdGFuZ2xlcyk7XG4vLyBlbmFibGUgdGhlIHBsdWdpbiBmb3IgZHJhd2luZyBvbiB0aGUgbWFwXG5sZXQgZHJhd0NvbnRyb2wgPSBuZXcgTC5Db250cm9sLkRyYXcoe1xuICAgIGVkaXQ6IHtcbiAgICAgICAgZmVhdHVyZUdyb3VwOiBsYXllckZvclVzZXJSZWN0YW5nbGVzXG4gICAgfSxcbiAgICBkcmF3OiB7XG4gICAgICAgIGNpcmNsZTogZmFsc2UsXG4gICAgICAgIGNpcmNsZW1hcmtlcjogZmFsc2UsXG4gICAgICAgIG1hcmtlcjogZmFsc2UsXG4gICAgICAgIHBvbHlnb246IGZhbHNlLFxuICAgICAgICBwb2x5bGluZTogZmFsc2UsXG4gICAgfVxufSk7XG5tYXAuYWRkQ29udHJvbChkcmF3Q29udHJvbCk7XG5cbi8qKlxuICogQSBmdW5jdGlvbiB3aGljaCBjb2xsZWN0cyB3aGF0IHRoZSB1c2VyIGhhcyBkcmF3biBhbmQgcGFzcyBpdCB0byBhIGNhbGxiYWNrXG4gKiBAcGFyYW0geyhyZWN0YW5nbGU6IFJlY3RhbmdsZSkgPT4gYW55fSBjYWxsYmFja09uUmVjdERyYXduXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrT25EZWxldGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZURyYXdpbmcoY2FsbGJhY2tPblJlY3REcmF3bjogKHJlY3RhbmdsZTogTC5SZWN0YW5nbGUpID0+IGFueSwgY2FsbGJhY2tPbkRlbGV0ZTogKCkgPT4gdm9pZCkge1xuICAgIC8vIHRvZG8gaGFuZGxlIFwiZWRpdGVkXCIgdG9vXG4gICAgbWFwLm9uKCdkcmF3OmNyZWF0ZWQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBsZXQgdHlwZSA9IGUubGF5ZXJUeXBlLFxuICAgICAgICAgICAgbGF5ZXIgPSBlLmxheWVyO1xuICAgICAgICBpZiAodHlwZSAhPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBsYXllckZvclVzZXJSZWN0YW5nbGVzLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHR5cGUgKyBcIiBkcmF3blwiKTtcbiAgICAgICAgbGV0IGxhdGxuZ3MgPSBsYXllci5nZXRMYXRMbmdzKClbMF07XG4gICAgICAgIGxheWVyRm9yVXNlclJlY3RhbmdsZXMuYWRkTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQm91bmRhcmllcyBvZiB0aGUgYXJlYSBvZiBpbnRlcmVzdDpcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGxhdGxuZ3MpKTtcblxuICAgICAgICAvLyBwcmVwYXJlIHRoZSByZXN1bHQgdG8gYmUgdXNlZCBmb3IgY29uc3RydWN0aW5nIGEgcmVjdGFuZ2xlXG4gICAgICAgIGNvbnN0IHJlY3RhbmdsZUJvdW5kczogTC5MYXRMbmdCb3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhsYXRsbmdzLm1hcChmdW5jdGlvbiAoY29vcmQpOiBbbnVtYmVyLCBudW1iZXJdIHtcbiAgICAgICAgICAgIHJldHVybiBbY29vcmQubGF0LCBjb29yZC5sbmddXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gbWFrZSB0aGUgcmVjdGFuZ2xlLCB3aGljaCBlbmNvbXBhc3NlcyB0aGUgYXJlYSB3aGljaCB3ZSB3YW50IHRvIGZpbGwgd2l0aCBjaXJjbGVzXG4gICAgICAgIGNvbnN0IGJvdW5kaW5nUmVjdGFuZ2xlOiBMLlJlY3RhbmdsZSA9IEwucmVjdGFuZ2xlKHJlY3RhbmdsZUJvdW5kcyk7XG5cbiAgICAgICAgLy8gcGFzcyB0aGUgcmVjdGFuZ2xlIHRvIHRoZSBjYWxsYmFja1xuICAgICAgICBjYWxsYmFja09uUmVjdERyYXduKGJvdW5kaW5nUmVjdGFuZ2xlKTtcbiAgICB9KTtcbiAgICBtYXAub24oXCJkcmF3OmRlbGV0ZWRcIiwgY2FsbGJhY2tPbkRlbGV0ZSlcblxufVxuXG52YXIgbXlSZW5kZXJlciA9IEwuY2FudmFzKHtwYWRkaW5nOiAwLjV9KTtcblxuLyoqXG4gKiBHaXZlbiBhIGxheWVyLCBjb29yZGluYXRlcyBvZiB0aGUgY2VudGVyIG9mIGNpcmNsZXMgYW5kIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZSxcbiAqIGRyYXcgdGhlIGNpcmNsZXMgb24gdGhlIGxheWVyXG4gKiBAcGFyYW0ge0xhdExuZ1tdfSBjb29yZHNcbiAqIEBwYXJhbSB7TGF5ZXJHcm91cH0gbGF5ZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaXJjbGVSYWRpdXNcbiAqIEBwYXJhbSB7e319IGNpcmNsZU9wdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGNvb3JkczogTC5MYXRMbmdbXSwgbGF5ZXI6IEwuTGF5ZXJHcm91cCwgY2lyY2xlUmFkaXVzID0gMzAwLCBjaXJjbGVPcHRpb25zID0ge30pIHtcbiAgICBsZXQgb3B0cyA9IHtcbiAgICAgICAgY29sb3I6IFwicmVkXCIsXG4gICAgICAgIC4uLmNpcmNsZU9wdGlvbnNcbiAgICB9O1xuICAgIGNvb3Jkcy5mb3JFYWNoKChjb29yZDogTC5MYXRMbmcpID0+IHtcbiAgICAgICAgTC5jaXJjbGUoY29vcmQsIHtyYWRpdXM6IGNpcmNsZVJhZGl1c30sIGNpcmNsZU9wdGlvbnMpLmFkZFRvKGxheWVyKVxuICAgIH0pXG59XG5cblxuXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/map.ts\n");

/***/ })

/******/ });